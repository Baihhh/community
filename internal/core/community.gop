/*
 * Copyright (c) 2023 The GoPlus Authors (goplus.org). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package core

import (
	"context"
	"io"
	"os"
	"time"
	"fmt"
	"database/sql"
	_ "github.com/go-sql-driver/mysql"
)

var (
	ErrNotExist = os.ErrNotExist
	// Config *Config
	DB *sql.DB
)

// Mysql config.
type Mysql struct {
	Ip           string
	Port         int
	Username     string
	Password     string
	Database     string
}

type Config struct {
	Mysql
}

type ArticleEntry struct {
	ID    string
	Title string
	Ctime time.Time
	Mtime time.Time
}

type Article struct {
	ArticleEntry
	AccountId string
	Tags string
	Status int
	CoverId int
	MarkdownText string
	HtmlText string
	Content []byte // in markdown
}

type Community struct {
}

func New(conf *Config) (*Community, error) {
	return &Community{}, nil
}

// InitMysqlDB init mysql connection.
func InitMysqlDB(conf *Config) {
	// dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=utf8mb4&parseTime=True&loc=Local",
	// conf.Mysql.Username,
	// conf.Mysql.Password,
	// conf.Mysql.Ip,
	// conf.Mysql.Port,
	// conf.Mysql.Database,
	// )
	dsn := "root:password@tcp(127.0.0.1:3306)/community"

	db, err := sql.Open("mysql", dsn)
	if err!=nil{
        println err
        return
    }

    err =db.Ping()
    if err!=nil{
        println err
        return
    }

	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(10)

	DB = db

	println "mysql connected"
}


// Article returns an article.
func (p *Community) Article(ctx context.Context, id string) (article *Article, err error) {
	article = &Article{}
	sqlStr := "select id,title,account_id,status,markdown_text,html_text from article where id=?"
	err = DB.QueryRow(sqlStr, id).Scan(&article.ID,&article.Title,&article.AccountId,&article.Status,&article.MarkdownText,&article.HtmlText)
	if err != nil {
		println "not found the article"
		return article, ErrNotExist
	}
	return
}

// CanEditable
func (p *Community) CanEditable(ctx context.Context, uid, id string) (editable bool, err error) {
	return true, nil
}

// PutArticle adds new article (ID == "") or edits an existing article (ID != "").
func (p *Community) PutArticle(ctx context.Context, uid string, article *Article) (id string, err error) {
	return
}

func (p *Community) DeleteArticle(ctx context.Context, uid, id string) (err error) {
	return
}

const (
	MarkBegin = ""
	MarkEnd   = "eof"
)

// ListArticle lists articles from an position.
func (p *Community) ListArticle(ctx context.Context, from string, limit int) (items []*ArticleEntry, next string, err error) {
	if from == MarkBegin {
		item := &ArticleEntry{
			ID:    "123",
			Title: "Title",
		}
		return []*ArticleEntry{item}, MarkEnd, nil
	}
	return nil, MarkEnd, io.EOF
}
