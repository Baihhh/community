/*
 * Copyright (c) 2023 The GoPlus Authors (goplus.org). All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package core

import (
	"context"
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
	"io"
	"os"
	"strconv"
	"time"
)

var (
	ErrNotExist = os.ErrNotExist
	// Config *Config
	DB *sql.DB
)

type Config struct {
	DNS string
}

type ArticleEntry struct {
	ID    string
	Title string
	UId   string
	Cover string
	Tags  string
	Ctime time.Time
	Mtime time.Time
}

type Article struct {
	ArticleEntry
	Status  int    // published or draft
	Content string // markdown text
	HtmlUrl string // parsed html file url
}

type Community struct {
}

func New(conf *Config) (*Community, error) {
	return &Community{}, nil
}

// InitMysqlDB init mysql connection.
func InitMysqlDB(conf *Config) {
	db, err := sql.Open("mysql", conf.DNS)
	if err != nil {
		println err
		return
	}

	err = db.Ping()
	if err != nil {
		println err
		return
	}

	db.SetMaxOpenConns(10)
	db.SetMaxIdleConns(10)

	DB = db

	println "mysql connected"
}

// Article returns an article.
func (p *Community) Article(ctx context.Context, id string) (article *Article, err error) {
	article = &Article{}
	sqlStr := "select id,title,user_id,status,content,html_url from article where id=?"
	err = DB.QueryRow(sqlStr, id).Scan(&article.ID, &article.Title, &article.UId, &article.Status, &article.Content, &article.HtmlUrl)
	if err != nil {
		println "not found the article"
		return article, ErrNotExist
	}
	// TODO add author
	return
}

// CanEditable
func (p *Community) CanEditable(ctx context.Context, uid, id string) (editable bool, err error) {
	sqlStr := "select id from article where id=? and user_id = ?"
	err = DB.QueryRow(sqlStr, id, uid).Scan(&id)
	if err != nil {
		return false, err
	}
	return true, nil
}

// PutArticle adds new article (ID == "") or edits an existing article (ID != "").
func (p *Community) PutArticle(ctx context.Context, uid string, article *Article) (id string, err error) {
	// new article
	if article.ID == "" {
		sqlStr := "insert into article (title, ctime, mtime, user_id, tags, status, cover, content, html_url) values (?, ?, ?, ?, ?, ?, ?, ?, ?)"
		res, err := DB.Exec(sqlStr, &article.Title, time.Now(), time.Now(), &article.UId, &article.Tags, &article.Status, &article.Cover, &article.Content, &article.HtmlUrl)
		if err != nil {
			return "", err
		}
		idInt, err := res.LastInsertId()
		return strconv.FormatInt(idInt, 10), nil
	}
	// edit article
	// can uid edit the article
	canEdit, err := p.CanEditable(ctx, uid, article.ID)
	if !canEdit {
		println "no permissions"
		return
	}
	sqlStr := "update article set title=?, mtime=?, tags=?, status=?, cover=?, content=?, html_url=? where id=?"
	_, err = DB.Exec(sqlStr, &article.Title, time.Now(), &article.Tags, &article.Status, &article.Cover, &article.Content, &article.HtmlUrl, &article.ID)
	return article.ID, err
}

func (p *Community) DeleteArticle(ctx context.Context, uid, id string) (err error) {
	// can uid delete the article
	canEdit, err := p.CanEditable(ctx, uid, id)
	if !canEdit {
		println "no permissions"
		return
	}
	sqlStr := "delete from article where id=?"
	_, err = DB.Exec(sqlStr, id)
	// TODO delete the media
	return
}

const (
	published = 1
	draft     = 0
)

// ListArticle lists articles from an position.
func (p *Community) ListArticle(ctx context.Context, from int, limit int) (items []*ArticleEntry, next int, err error) {
	sqlStr := "select id, title, ctime, user_id, tags, cover from article where status = ? limit ? offset ?"
	rows, err := DB.Query(sqlStr, published, limit, from)
	if err != nil {
		println err
		return []*ArticleEntry{}, from, err
	}
	defer rows.Close()

	var rowLen int
	for rows.Next() {
		article := &ArticleEntry{}
		err := rows.Scan(&article.ID, &article.Title, &article.Ctime, &article.UId, &article.Tags, &article.Cover)
		if err != nil {
			println err
			return []*ArticleEntry{}, from, err
		}
		// TODO add author
		items = append(items, article)
		rowLen++
	}
	return items, from + rowLen, nil
}
